{"language": "Solidity", "sources": {"UsdcPriceDataProvider.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.2;\n\nimport \"IERC20Metadata.sol\";\n\nimport \"AggregatorDataProvider.sol\";\nimport \"IPriceDataProvider.sol\";\n\ncontract UsdcPriceDataProvider is\n    AggregatorDataProvider, \n    IPriceDataProvider\n{\n    address public constant USDC_CONTACT_ADDRESS_MAINNET = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address public constant USDC_CONTACT_ADDRESS_GOERLI = 0x07865c6E87B9F70255377e024ace6630C1Eaa37F;\n\n    address public constant CHAINLINK_USDC_USD_FEED_MAINNET = 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6;\n    address public constant CHAINLINK_USDC_USD_FEED_GOERLI = 0xAb5c49580294Aff77670F839ea425f5b78ab3Ae7;\n    uint8 public constant CHAINLINK_USDC_DECIMALS = 8;\n\n    uint256 public constant DEPEG_TRIGGER_PRICE = 995 * 10**CHAINLINK_USDC_DECIMALS / 1000; // USDC below 0.995 USD triggers depeg alert\n    uint256 public constant DEPEG_RECOVERY_PRICE = 999 * 10**CHAINLINK_USDC_DECIMALS / 1000; // USDC at/above 0.999 USD is find and/or is considered a recovery from a depeg alert\n    uint256 public constant DEPEG_RECOVERY_WINDOW = 24 * 3600;\n\n    uint256 public constant PRICE_INFO_HISTORY_DURATION = 7 * 24 * 3600; // keep price info for 1 week\n\n    string public constant CHAINLINK_TEST_DESCRIPTION = \"USDC / USD (Ganache)\";\n    uint256 public constant CHAINLINK_TEST_VERSION = 4;\n\n    // see https://docs.chain.link/data-feeds/price-feeds/addresses\n    // deviation: 0.25%\n    // heartbeat: 86400 (=24 * 60 * 60)\n    uint256 public constant CHAINLINK_USDC_USD_DEVIATION = 25 * 10**CHAINLINK_USDC_DECIMALS / 10000;\n    uint256 public constant CHAINLINK_HEARTBEAT_MARGIN = 100;\n    uint256 public constant CHAINLINK_USDC_USD_HEARTBEAT = 24 * 3600;\n\n    uint8 public constant PRICE_HISTORY_SIZE = 20;\n\n    IERC20Metadata private _token;\n\n    PriceInfo private _depegPriceInfo;\n    uint256 private _triggeredAt;\n    uint256 private _depeggedAt;\n    uint256 private _depeggedBlockNumber;\n\n    constructor(address tokenAddress) \n        AggregatorDataProvider(\n            CHAINLINK_USDC_USD_FEED_MAINNET, \n            CHAINLINK_USDC_USD_FEED_GOERLI, \n            CHAINLINK_USDC_USD_DEVIATION,\n            CHAINLINK_USDC_USD_HEARTBEAT,\n            CHAINLINK_HEARTBEAT_MARGIN,\n            CHAINLINK_TEST_DESCRIPTION,\n            CHAINLINK_USDC_DECIMALS,\n            CHAINLINK_TEST_VERSION\n        )\n    {\n        if(isMainnet()) {\n            if(block.chainid == 1) {\n                _token = IERC20Metadata(USDC_CONTACT_ADDRESS_MAINNET);\n            } else if(block.chainid == 5) {\n                _token = IERC20Metadata(USDC_CONTACT_ADDRESS_GOERLI);\n            } else {\n                revert(\"ERROR:UPDP-010:CHAIN_NOT_SUPPORTET\");\n            }\n        } else if(isTestnet()) {\n            require(tokenAddress != address(0), \"ERROR:DP-011:TOKEN_ZERO\");\n            _token = IERC20Metadata(tokenAddress);\n        } else {\n            revert(\"ERROR:UPDP-012:CHAIN_NOT_SUPPORTET\");\n        }\n\n        _triggeredAt = 0;\n        _depeggedAt = 0;\n        _depeggedBlockNumber = 0;\n    }\n\n\n    function getLatestPriceInfo()\n        public override\n        view\n        returns(PriceInfo memory priceInfo)\n    {\n        (\n            uint80 roundId,\n            int256 answer,\n            , // startedAt unused\n            uint256 updatedAt,\n             // answeredInRound unused\n        ) = latestRoundData();\n\n        require(answer >= 0, \"ERROR:UPDP-020:NEGATIVE_PRICE_VALUES_INVALID\");\n\n        uint256 price = uint256(answer);\n\n        IPriceDataProvider.ComplianceState compliance = getComplianceState(roundId, price, updatedAt);\n        IPriceDataProvider.StabilityState stability = getStability(roundId, price, updatedAt);\n\n        // calculate event type, triggered at and depegged at\n        IPriceDataProvider.EventType eventType = IPriceDataProvider.EventType.Update;\n        uint256 triggeredAt = _triggeredAt;\n        uint256 depeggedAt = _depeggedAt;\n        \n        // check all possible state changing transitions\n        // enter depegged state\n        if(stability == IPriceDataProvider.StabilityState.Depegged && _depeggedAt == 0) {\n            eventType = IPriceDataProvider.EventType.DepegEvent;\n            depeggedAt = updatedAt;\n        // enter triggered state\n        } else if(stability == IPriceDataProvider.StabilityState.Triggered && _triggeredAt == 0) {\n            eventType = IPriceDataProvider.EventType.TriggerEvent;\n            triggeredAt = updatedAt;\n        // recover from triggered state\n        } else if(stability == IPriceDataProvider.StabilityState.Stable && _triggeredAt > 0) {\n            eventType = IPriceDataProvider.EventType.RecoveryEvent;\n        }\n\n        return PriceInfo(\n            roundId,\n            price,\n            compliance,\n            stability,\n            eventType,\n            triggeredAt,\n            depeggedAt,\n            updatedAt\n        );\n    }\n\n\n    function processLatestPriceInfo()\n        public override\n        returns(PriceInfo memory priceInfo)\n    {\n        priceInfo = getLatestPriceInfo();\n\n        if(priceInfo.eventType == IPriceDataProvider.EventType.DepegEvent) {\n            _depegPriceInfo = priceInfo;\n            _depeggedAt = priceInfo.depeggedAt;\n\n            emit LogPriceDataDepegged(\n                priceInfo.id,\n                priceInfo.price,\n                priceInfo.triggeredAt,\n                priceInfo.depeggedAt);\n\n        } else if(priceInfo.eventType == IPriceDataProvider.EventType.TriggerEvent) {\n            _triggeredAt = priceInfo.triggeredAt;\n\n            emit LogPriceDataTriggered(\n                priceInfo.id,\n                priceInfo.price,\n                priceInfo.triggeredAt);\n\n        } else if(priceInfo.eventType == IPriceDataProvider.EventType.RecoveryEvent) {\n            _triggeredAt = 0;\n\n            emit LogPriceDataRecovered(\n                priceInfo.id,\n                priceInfo.price,\n                priceInfo.triggeredAt,\n                priceInfo.createdAt);\n        } else {\n            emit LogPriceDataProcessed(\n                priceInfo.id,\n                priceInfo.price,\n                priceInfo.createdAt);\n        }\n\n    }\n\n\n    function forceDepegForNextPriceInfo()\n        external override\n        onlyOwner()\n        onlyTestnet()\n    {\n        require(_triggeredAt > DEPEG_RECOVERY_WINDOW, \"ERROR:UPDP-030:TRIGGERED_AT_TOO_SMALL\");\n\n        _triggeredAt -= DEPEG_RECOVERY_WINDOW;\n\n        emit LogUsdcProviderForcedDepeg(_triggeredAt, block.timestamp);\n    }\n\n    function resetDepeg()\n        external override\n        onlyOwner()\n        onlyTestnet()\n    {\n        _depegPriceInfo.id = 0;\n        _depegPriceInfo.price = 0;\n        _depegPriceInfo.compliance = IPriceDataProvider.ComplianceState.Undefined;\n        _depegPriceInfo.stability = IPriceDataProvider.StabilityState.Undefined;\n        _depegPriceInfo.triggeredAt = 0;\n        _depegPriceInfo.depeggedAt = 0;\n        _depegPriceInfo.createdAt = 0;\n\n        _triggeredAt = 0;\n        _depeggedAt = 0;\n\n        emit LogUsdcProviderResetDepeg(block.timestamp);\n    }\n\n\n    function isNewPriceInfoEventAvailable()\n        external override\n        view\n        returns(\n            bool newEvent, \n            PriceInfo memory priceInfo,\n            uint256 timeSinceEvent\n        )\n    {\n        priceInfo = getLatestPriceInfo();\n        newEvent = !(priceInfo.eventType == IPriceDataProvider.EventType.Undefined \n            || priceInfo.eventType == IPriceDataProvider.EventType.Update);\n        timeSinceEvent = priceInfo.createdAt == 0 ? 0 : block.timestamp - priceInfo.createdAt;\n    }\n\n\n    function getCompliance(\n        uint80 roundId,\n        uint256 price,\n        uint256 updatedAt\n    )\n        public view\n        returns(\n            bool priceDeviationIsValid,\n            bool heartbeetIsValid,\n            uint256 previousPrice,\n            uint256 previousUpdatedAt\n        )\n    {\n        if(roundId == 0) {\n            return (\n                true,\n                true,\n                0,\n                0);\n        }\n\n        (\n            , // roundId unused\n            int256 previousPriceInt,\n            , // startedAt unused\n            uint256 previousUpdatedAtUint,\n             // answeredInRound unused\n        ) = getRoundData(roundId - 1);\n\n        if(previousUpdatedAtUint == 0) {\n            return (\n                true,\n                true,\n                previousPrice,\n                previousUpdatedAtUint);\n        }\n\n        previousPrice = uint256(previousPriceInt);\n\n        return (\n            !isExceedingDeviation(price, previousPrice),\n            !isExceedingHeartbeat(updatedAt, previousUpdatedAtUint),\n            previousPrice,\n            previousUpdatedAtUint);\n    }\n\n\n    function getStability(\n        uint256 roundId,\n        uint256 price,\n        uint256 updatedAt\n    )\n        public\n        view\n        returns(IPriceDataProvider.StabilityState stability)\n    {\n        // no price data available (yet)\n        // only expected with test setup\n        if(updatedAt == 0) {\n            return IPriceDataProvider.StabilityState.Initializing;\n        }\n\n        // once depegged, state remains depegged\n        if(_depeggedAt > 0) {\n            return IPriceDataProvider.StabilityState.Depegged;\n        }\n\n        // check triggered state:\n        // triggered and not recovered within recovery window\n        if(_triggeredAt > 0) {\n\n            // check if recovery run out of time and we have depegged\n            if(updatedAt - _triggeredAt > DEPEG_RECOVERY_WINDOW) {\n                return IPriceDataProvider.StabilityState.Depegged;\n            }\n\n            // check for recovery\n            if(price >= DEPEG_RECOVERY_PRICE) {\n                return IPriceDataProvider.StabilityState.Stable;\n            }\n\n            // remaining in triggered state\n            return IPriceDataProvider.StabilityState.Triggered;\n        } \n\n        // check potential change into triggerd state\n        if(price <= DEPEG_TRIGGER_PRICE) {\n            return IPriceDataProvider.StabilityState.Triggered;\n        }\n\n        // everything fine \n        return IPriceDataProvider.StabilityState.Stable;\n    }\n\n\n    function getComplianceState(\n        uint256 roundId,\n        uint256 price,\n        uint256 updatedAt\n    )\n        public\n        view\n        returns(IPriceDataProvider.ComplianceState compliance)\n    {\n        (\n            bool priceDeviationIsValid,\n            bool heartbeetIsValid,\n            uint256 previousPrice,\n            uint256 previousUpdatedAt\n        ) = getCompliance(uint80(roundId), price, updatedAt);\n\n        if(previousUpdatedAt == 0) {\n            return IPriceDataProvider.ComplianceState.Initializing;\n        }\n\n        if(priceDeviationIsValid && heartbeetIsValid) {\n            return IPriceDataProvider.ComplianceState.Valid;\n        }\n\n        (\n            bool previousPriceDeviationIsValid,\n            bool previousHeartbeetIsValid,\n            , // previousPrice not usedc\n            uint256 prePreviousUpdatedAt\n        ) = getCompliance(uint80(roundId-1), previousPrice, previousUpdatedAt);\n\n        if((previousPriceDeviationIsValid && previousHeartbeetIsValid)\n            || prePreviousUpdatedAt == 0)\n        {\n            return IPriceDataProvider.ComplianceState.FailedOnce;\n        }\n\n        return IPriceDataProvider.ComplianceState.FailedMultipleTimes;\n    }\n\n    function getDepegPriceInfo()\n        public override\n        view\n        returns(PriceInfo memory priceInfo)\n    {\n        return _depegPriceInfo;\n    }\n\n    function getTargetPrice() external override view returns(uint256 targetPrice) {\n        return 10 ** decimals();\n    }\n\n    function getTriggeredAt() external override view returns(uint256 triggeredAt) {\n        return _triggeredAt;\n    }\n\n    function getDepeggedAt() external override view returns(uint256 depeggedAt) {\n        return _depeggedAt;\n    }\n\n    function getAggregatorAddress() external override view returns(address priceInfoSourceAddress) {\n        return getChainlinkAggregatorAddress();\n    }\n\n    function getHeartbeat() external override view returns(uint256 heartbeatSeconds) {\n        return heartbeat();\n    }\n\n    function getDeviation() external override view returns(uint256 deviationLevel) {\n        return deviation();\n    }\n\n    function getDecimals() external override view returns(uint8 priceInfoDecimals) {\n        return decimals();\n    }\n\n    function getToken() external override view returns(address) {\n        return address(_token);\n    }\n\n    function getOwner() external override view returns(address) {\n        return owner();\n    }\n\n    function isMainnetProvider()\n        public override\n        view\n        returns(bool)\n    {\n        return isMainnet();\n    }\n\n    function isTestnetProvider()\n        public override\n        view\n        returns(bool)\n    {\n        return isTestnet();\n    }\n\n}\n"}, "IERC20Metadata.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"}, "IERC20.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"}, "AggregatorDataProvider.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.2;\n\nimport \"Ownable.sol\";\n\n// V2V3 combines AggregatorInterface and AggregatorV3Interface\nimport \"AggregatorV2V3Interface.sol\";\n\ncontract AggregatorDataProvider is \n    Ownable,\n    AggregatorV2V3Interface\n{\n    // matches return data for latestRoundData\n    struct ChainlinkRoundData {\n        uint80 roundId;\n        int256 answer;\n        uint256 startedAt;\n        uint256 updatedAt;\n        uint80 answeredInRound;\n    }\n\n    uint256 public constant MAINNET = 1;\n    uint256 public constant GOERLI = 5;\n\n    uint256 public constant GANACHE = 1337;\n    uint256 public constant GANACHE2 = 1234;\n    uint256 public constant MUMBAI = 80001;\n    uint256 public constant ZKEVM_TEST = 1442;\n    \n    AggregatorV2V3Interface private _aggregator;\n\n    uint256 private _deviation;\n    uint256 private _heartbeat;\n    uint256 private _heartbeatMargin;\n\n    string private _description;\n    uint8 private _decimals;\n    uint256 private _version;\n\n    mapping(uint80 /* round id */ => ChainlinkRoundData) private _aggregatorData;\n    uint80 [] private _roundIds;\n    uint80 private _maxRoundId;\n\n    modifier onlyTestnet() {\n        require(isTestnet(), \"ERROR:ADP-001:NOT_TEST_CHAIN\");\n        _;\n    }\n\n    constructor(\n        address aggregatorAddressMainnet,\n        address aggregatorAddressGoerli,\n        uint256 deviationLevel, // 10**decimals() corresponding to 100%\n        uint256 heartbeatSeconds,\n        uint256 heartbeatMarginSeconds,\n        string memory testDescription,\n        uint8 testDecimals,\n        uint256 testVersion\n    ) \n        Ownable()\n    {\n        if(isMainnet()) {\n            if(block.chainid == 1) {\n                _aggregator = AggregatorV2V3Interface(aggregatorAddressMainnet);\n            } else if(block.chainid == 5) {\n                _aggregator = AggregatorV2V3Interface(aggregatorAddressGoerli);\n            }\n        } else if(isTestnet()) {\n            _aggregator = AggregatorV2V3Interface(address(this));\n        } else {\n            revert(\"ERROR:ADP-010:CHAIN_NOT_SUPPORTET\");\n        }\n\n        _description = testDescription;\n        _decimals = testDecimals;\n        _version = testVersion;\n\n        _deviation = deviationLevel;\n        _heartbeat = heartbeatSeconds;\n        _heartbeatMargin = heartbeatMarginSeconds;\n\n        _maxRoundId = 0;\n    }\n\n    function addRoundData(\n        int256 answer,\n        uint256 startedAt\n    )\n        external\n    {\n        _maxRoundId++;\n        setRoundData(\n            _maxRoundId,\n            answer,\n            startedAt,\n            startedAt, // set updatedAt == startedAt\n            _maxRoundId\n        );\n    }\n\n\n    function setRoundData (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    )\n        public\n        onlyOwner()\n        onlyTestnet()\n    {\n        // update max roundId if necessary\n        if(roundId > _maxRoundId) {\n            _maxRoundId = roundId;\n        }\n\n        _roundIds.push(roundId);\n        _aggregatorData[roundId] = ChainlinkRoundData(\n            roundId,\n            answer,\n            startedAt,\n            updatedAt,\n            answeredInRound\n        );\n    }\n\n    function getRoundData(uint80 _roundId)\n        public override\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        if(isMainnet()) {\n            return _aggregator.getRoundData(_roundId);\n        }\n\n        ChainlinkRoundData memory data = _aggregatorData[_roundId];\n\n        return (\n            data.roundId,\n            data.answer,\n            data.startedAt,\n            data.updatedAt,\n            data.answeredInRound\n        );\n    }\n\n    function getChainlinkAggregatorAddress() public view returns(address) {\n        return address(_aggregator);\n    }\n\n    function isExceedingDeviation(uint256 price1, uint256 price2) \n        public \n        view \n        returns(bool isExceeding)\n    {\n        if(price1 >= price2) {\n            if(price1 - price2 > _deviation) {\n                return true;\n            }\n        }\n        else if(price2 - price1 > _deviation) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function isExceedingHeartbeat(uint256 time1, uint256 time2) \n        public \n        view \n        returns(bool isExceeding)\n    {\n        if(time1 >= time2) {\n            if(time1 - time2 > _heartbeat + _heartbeatMargin) {\n                return true;\n            }\n        }\n        else if(time2 - time1 > _heartbeat + _heartbeatMargin) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function deviation() public view returns (uint256) {\n        return _deviation;\n    }\n\n    function heartbeat() public view returns (uint256) {\n        return _heartbeat;\n    }\n\n    function heartbeatMargin() public view returns (uint256) {\n        return _heartbeatMargin;\n    }\n\n    function latestAnswer() external override view returns (int256) {\n        if(isMainnet()) {\n            return _aggregator.latestAnswer();\n        }\n\n        return _aggregatorData[_maxRoundId].answer;\n    }\n\n    function latestTimestamp() external override view returns (uint256) {\n        if(isMainnet()) {\n            return _aggregator.latestTimestamp();\n        }\n\n        return _aggregatorData[_maxRoundId].updatedAt;\n    }\n\n    function latestRound() external override view returns (uint256) {\n        if(isMainnet()) {\n            return _aggregator.latestRound();\n        }\n\n        return _maxRoundId;\n    }\n\n    function getAnswer(uint256 roundId) external override view returns (int256) {\n        if(isMainnet()) {\n            return _aggregator.getAnswer(roundId);\n        }\n\n        return _aggregatorData[uint80(roundId)].answer;\n    }\n\n    function getTimestamp(uint256 roundId) external override view returns (uint256) {\n        if(isMainnet()) {\n            return _aggregator.getTimestamp(roundId);\n        }\n\n        return _aggregatorData[uint80(roundId)].updatedAt;\n    }\n\n    function description() public override view returns (string memory) {\n        if(isMainnet()) {\n            return _aggregator.description();\n        }\n\n        return _description;\n    }\n\n    function decimals() public override view returns(uint8) {\n        if(isMainnet()) {\n            return _aggregator.decimals();\n        }\n\n        return _decimals;\n    }\n\n    function version() public override view returns (uint256) {\n        if(isMainnet()) {\n            return _aggregator.version();\n        }\n\n        return _version;\n    }\n\n    function latestRoundData()\n        public override\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        if(isMainnet()) {\n            return _aggregator.latestRoundData();\n        }\n\n        return getRoundData(_maxRoundId);\n    }\n\n    function isMainnet()\n        public\n        view\n        returns(bool)\n    {\n        return (block.chainid == MAINNET)\n            || (block.chainid == GOERLI);\n    }    \n\n    function isTestnet()\n        public\n        view\n        returns(bool)\n    {\n        return (block.chainid == GANACHE)\n            || (block.chainid == GANACHE2)\n            || (block.chainid == MUMBAI)\n            || (block.chainid == ZKEVM_TEST);\n    }    \n}\n"}, "Ownable.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"}, "Context.sol": {"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"}, "AggregatorV2V3Interface.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"AggregatorInterface.sol\";\nimport \"AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"}, "AggregatorInterface.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"}, "AggregatorV3Interface.sol": {"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"}, "IPriceDataProvider.sol": {"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.2;\n\ninterface IPriceDataProvider {\n\n    enum ComplianceState {\n        Undefined,\n        Initializing,\n        Valid,\n        FailedOnce,\n        FailedMultipleTimes\n    }\n\n    enum StabilityState {\n        Undefined,\n        Initializing,\n        Stable,\n        Triggered,\n        Depegged\n    }\n\n    enum EventType {\n        Undefined,\n        Update,\n        TriggerEvent,\n        RecoveryEvent,\n        DepegEvent\n    }\n\n    event LogPriceDataDeviationExceeded (\n        uint256 priceId,\n        uint256 priceDeviation,\n        uint256 currentPrice,\n        uint256 lastPrice);\n\n    event LogPriceDataHeartbeatExceeded (\n        uint256 priceId,\n        uint256 timeDifference,\n        uint256 currentCreatedAt,\n        uint256 lastCreatedAt);\n\n    event LogPriceDataTriggered (\n        uint256 priceId,\n        uint256 price,\n        uint256 triggeredAt);\n\n    event LogPriceDataRecovered (\n        uint256 priceId,\n        uint256 price,\n        uint256 triggeredAt,\n        uint256 recoveredAt);\n\n    event LogPriceDataDepegged (\n        uint256 priceId,\n        uint256 price,\n        uint256 triggeredAt,\n        uint256 depeggedAt);\n\n    event LogPriceDataProcessed (\n        uint256 priceId,\n        uint256 price,\n        uint256 createdAt);\n\n    event LogUsdcProviderForcedDepeg (\n        uint256 updatedTriggeredAt,\n        uint256 forcedDepegAt);\n\n    event LogUsdcProviderResetDepeg (\n        uint256 resetDepegAt);\n\n    struct PriceInfo {\n        uint256 id;\n        uint256 price;\n        ComplianceState compliance;\n        StabilityState stability;\n        EventType eventType;\n        uint256 triggeredAt;\n        uint256 depeggedAt;\n        uint256 createdAt;\n    }\n\n    function processLatestPriceInfo()\n        external \n        returns(PriceInfo memory priceInfo);\n\n    // only on testnets\n    function forceDepegForNextPriceInfo()\n        external;\n\n    // only on testnets\n    function resetDepeg()\n        external;\n\n    function isNewPriceInfoEventAvailable()\n        external\n        view\n        returns(\n            bool newEvent, \n            PriceInfo memory priceInfo,\n            uint256 timeSinceEvent);\n\n    function getLatestPriceInfo()\n        external\n        view \n        returns(PriceInfo memory priceInfo);\n\n    function getDepegPriceInfo()\n        external\n        view \n        returns(PriceInfo memory priceInfo);\n\n    function getTargetPrice() external view returns(uint256 targetPrice);\n\n    function getTriggeredAt() external view returns(uint256 triggeredAt);\n    function getDepeggedAt() external view returns(uint256 depeggedAt);\n\n    function getAggregatorAddress() external view returns(address aggregatorAddress);\n    function getHeartbeat() external view returns(uint256 heartbeatSeconds);\n    function getDeviation() external view returns(uint256 deviationLevel);\n    function getDecimals() external view returns(uint8 aggregatorDecimals);\n\n    function getToken() external view returns(address);\n    function getOwner() external view returns(address);\n\n    function isMainnetProvider() external view returns(bool);\n    function isTestnetProvider() external view returns(bool);\n}\n"}}, "settings": {"evmVersion": "istanbul", "optimizer": {"enabled": true, "runs": 200}, "libraries": {"UsdcPriceDataProvider.sol": {}}}}